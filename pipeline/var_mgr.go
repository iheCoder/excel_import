package pipeline

import (
	"strings"
	"unicode"
)

// Keywords contains Go's reserved keywords that cannot be used as variable names.
var (
	goKeywords = map[string]struct{}{
		"break": {}, "default": {}, "func": {}, "interface": {}, "select": {},
		"case": {}, "defer": {}, "go": {}, "map": {}, "struct": {},
		"chan": {}, "else": {}, "goto": {}, "package": {}, "switch": {},
		"const": {}, "fallthrough": {}, "if": {}, "range": {}, "type": {},
		"continue": {}, "for": {}, "import": {}, "return": {}, "var": {},
	}
)

type VarInfo struct {
	varName         string
	parentScopeKeys map[string]bool
	finalScopeKeys  map[string]bool
}

// VarMgr used to manage var generation and check scope conflict
// for simplifying the variable name generation, we have some rules:
// 1. scope will only have two levels: file scope and func scope.
// 2. variable name will be generated by upper case, last word or the random name.
type VarMgr struct {
	// rootScope is the root scope of the var manager.
	// it's represented by the global scope.
	// global scope is the go file scope of the generated code.
	rootScope *scope
	// globalVarPool is the global variable pool.
	globalVarPool map[string]*VarInfo
}

// NewVarMgr creates a new VarMgr.
func NewVarMgr() *VarMgr {
	return &VarMgr{
		rootScope:     &scope{},
		globalVarPool: make(map[string]*VarInfo),
	}
}

// AddScopeAtRoot creates a new scope at the root scope.
func (v *VarMgr) AddScopeAtRoot(key string) {
	s := &scope{
		key: key,
	}
	v.rootScope.children = append(v.rootScope.children, s)
	s.parent = v.rootScope
}

// AddVarInScope adds a variable to the current scope.
func (v *VarMgr) AddVarInScope(varName, scopeKey string) bool {
	// check the keyword conflict
	if checkKeywordConflict(varName) {
		return false
	}

	// find the scope
	s := v.findScope(scopeKey)
	if s == nil {
		return false
	}

	// check the conflict
	if !v.CheckVarConflict(varName, s) {
		return false
	}

	// register the var
	v.registerVar(varName, s)

	return true
}

func (v *VarMgr) registerVar(varName string, s *scope) {
	// get the var info
	vi, ok := v.globalVarPool[varName]
	if !ok {
		vi = &VarInfo{
			varName:         varName,
			parentScopeKeys: make(map[string]bool),
			finalScopeKeys:  make(map[string]bool),
		}
		v.globalVarPool[varName] = vi
	}

	// register the scope parentScopeKeys
	for _, psk := range s.parentScopeKeys {
		vi.parentScopeKeys[psk] = true
	}

	// register the scope key
	vi.finalScopeKeys[s.key] = true
}

func (v *VarMgr) CheckVarConflict(varName string, s *scope) bool {
	// check the global var pool
	vi, ok := v.globalVarPool[varName]
	if !ok {
		return true
	}

	// check the scope key exists in the var info
	if vi.parentScopeKeys[s.key] {
		return false
	}

	// check the scope parent keys exists in the var info
	for _, psk := range s.parentScopeKeys {
		if vi.finalScopeKeys[psk] {
			return false
		}
	}

	return true
}

// findScope finds the scope by the key.
func (v *VarMgr) findScope(key string) *scope {
	return v.findScopeRecursive(v.rootScope, key)
}

// findScopeRecursive finds the scope by the key recursively.
func (v *VarMgr) findScopeRecursive(s *scope, key string) *scope {
	if s.key == key {
		return s
	}

	for _, c := range s.children {
		if r := v.findScopeRecursive(c, key); r != nil {
			return r
		}
	}

	return nil
}

// GenerateVarNameByUpperCase generates a string by the upper case of the input string.
func GenerateVarNameByUpperCase(typeName string) string {
	if len(typeName) == 0 {
		return ""
	}

	var result []rune
	for _, r := range typeName {
		if unicode.IsUpper(r) {
			result = append(result, unicode.ToLower(r))
		}
	}

	// return first letter if no upper case letter
	if len(result) == 0 {
		return string(unicode.ToLower(rune(typeName[0])))
	}

	return string(result)
}

// GenerateVarNameByLastWord generates a string by the last word of the input string.
// The last word is the last continuous upper case characters.
// If there is no upper case character, the input string is returned.
// the first character of the result is lower case.
func GenerateVarNameByLastWord(typeName string) string {
	if len(typeName) == 0 {
		return ""
	}

	words := splitCamelCase(typeName)
	if len(words) > 0 {
		return strings.ToLower(words[len(words)-1])
	}

	return ""
}

// splitCamelCase splits a camel case string into words.
func splitCamelCase(input string) []string {
	var words []string
	var lastPos int
	for i := 1; i < len(input); i++ {
		if unicode.IsUpper(rune(input[i])) {
			words = append(words, input[lastPos:i])
			lastPos = i
		}
	}
	words = append(words, input[lastPos:])
	return words
}

func checkKeywordConflict(varName string) bool {
	_, ok := goKeywords[varName]
	return ok
}
